/*! jQuery UI - v1.12.1 - 2019-04-06 * http://jqueryui.com * Includes: widget.js, form-reset-mixin.js, labels.js, widgets/checkboxradio.js * Copyright jQuery Foundation and other contributors; Licensed MIT */ (function (factory) { if (typeof define === "function" && define.amd) { define(["jquery"], factory); } else { factory(jQuery); } }(function ($) { $.ui = $.ui || {}; var version = $.ui.version = "1.12.1"; /*! * jQuery UI Widget 1.12.1 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license */ var widgetUuid = 0; var widgetSlice = Array.prototype.slice; $.cleanData = (function (orig) { return function (elems) { var events, elem, i; for (i = 0; (elem = elems[i]) != null; i++) { try { events = $._data(elem, "events"); if (events && events.remove) { $(elem).triggerHandler("remove"); } } catch (e) { } } orig(elems); }; })($.cleanData); $.widget = function (name, base, prototype) { var existingConstructor, constructor, basePrototype; var proxiedPrototype = {}; var namespace = name.split(".")[0]; name = name.split(".")[1]; var fullName = namespace + "-" + name; if (!prototype) { prototype = base; base = $.Widget; } if ($.isArray(prototype)) { prototype = $.extend.apply(null, [{}].concat(prototype)); } $.expr[":"][fullName.toLowerCase()] = function (elem) { return !!$.data(elem, fullName); }; $[namespace] = $[namespace] || {}; existingConstructor = $[namespace][name]; constructor = $[namespace][name] = function (options, element) { if (!this._createWidget) { return new constructor(options, element); } if (arguments.length) { this._createWidget(options, element); } }; $.extend(constructor, existingConstructor, { version: prototype.version, _proto: $.extend({}, prototype), _childConstructors: [] }); basePrototype = new base(); basePrototype.options = $.widget.extend({}, basePrototype.options); $.each(prototype, function (prop, value) { if (!$.isFunction(value)) { proxiedPrototype[prop] = value; return; } proxiedPrototype[prop] = (function () { function _super() { return base.prototype[prop].apply(this, arguments); } function _superApply(args) { return base.prototype[prop].apply(this, args); } return function () { var __super = this._super; var __superApply = this._superApply; var returnValue; this._super = _super; this._superApply = _superApply; returnValue = value.apply(this, arguments); this._super = __super; this._superApply = __superApply; return returnValue; }; })(); }); constructor.prototype = $.widget.extend(basePrototype, { widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name }, proxiedPrototype, { constructor: constructor, namespace: namespace, widgetName: name, widgetFullName: fullName }); if (existingConstructor) { $.each(existingConstructor._childConstructors, function (i, child) { var childPrototype = child.prototype; $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto); }); delete existingConstructor._childConstructors; } else { base._childConstructors.push(constructor); } $.widget.bridge(name, constructor); return constructor; }; $.widget.extend = function (target) { var input = widgetSlice.call(arguments, 1); var inputIndex = 0; var inputLength = input.length; var key; var value; for (; inputIndex < inputLength; inputIndex++) { for (key in input[inputIndex]) { value = input[inputIndex][key]; if (input[inputIndex].hasOwnProperty(key) && value !== undefined) { if ($.isPlainObject(value)) { target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value); } else { target[key] = value; } } } } return target; }; $.widget.bridge = function (name, object) { var fullName = object.prototype.widgetFullName || name; $.fn[name] = function (options) { var isMethodCall = typeof options === "string"; var args = widgetSlice.call(arguments, 1); var returnValue = this; if (isMethodCall) { if (!this.length && options === "instance") { returnValue = undefined; } else { this.each(function () { var methodValue; var instance = $.data(this, fullName); if (options === "instance") { returnValue = instance; return false; } if (!instance) { return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'"); } if (!$.isFunction(instance[options]) || options.charAt(0) === "_") { return $.error("no such method '" + options + "' for " + name + " widget instance"); } methodValue = instance[options].apply(instance, args); if (methodValue !== instance && methodValue !== undefined) { returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue; return false; } }); } } else { if (args.length) { options = $.widget.extend.apply(null, [options].concat(args)); } this.each(function () { var instance = $.data(this, fullName); if (instance) { instance.option(options || {}); if (instance._init) { instance._init(); } } else { $.data(this, fullName, new object(options, this)); } }); } return returnValue; }; }; $.Widget = function () { }; $.Widget._childConstructors = []; $.Widget.prototype = { widgetName: "widget", widgetEventPrefix: "", defaultElement: "<div>", options: { classes: {}, disabled: false, create: null }, _createWidget: function (options, element) { element = $(element || this.defaultElement || this)[0]; this.element = $(element); this.uuid = widgetUuid++; this.eventNamespace = "." + this.widgetName + this.uuid; this.bindings = $(); this.hoverable = $(); this.focusable = $(); this.classesElementLookup = {}; if (element !== this) { $.data(element, this.widgetFullName, this); this._on(true, this.element, { remove: function (event) { if (event.target === element) { this.destroy(); } } }); this.document = $(element.style ? element.ownerDocument : element.document || element); this.window = $(this.document[0].defaultView || this.document[0].parentWindow); } this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options); this._create(); if (this.options.disabled) { this._setOptionDisabled(this.options.disabled); } this._trigger("create", null, this._getCreateEventData()); this._init(); }, _getCreateOptions: function () { return {}; }, _getCreateEventData: $.noop, _create: $.noop, _init: $.noop, destroy: function () { var that = this; this._destroy(); $.each(this.classesElementLookup, function (key, value) { that._removeClass(value, key); }); this.element.off(this.eventNamespace).removeData(this.widgetFullName); this.widget().off(this.eventNamespace).removeAttr("aria-disabled"); this.bindings.off(this.eventNamespace); }, _destroy: $.noop, widget: function () { return this.element; }, option: function (key, value) { var options = key; var parts; var curOption; var i; if (arguments.length === 0) { return $.widget.extend({}, this.options); } if (typeof key === "string") { options = {}; parts = key.split("."); key = parts.shift(); if (parts.length) { curOption = options[key] = $.widget.extend({}, this.options[key]); for (i = 0; i < parts.length - 1; i++) { curOption[parts[i]] = curOption[parts[i]] || {}; curOption = curOption[parts[i]]; } key = parts.pop(); if (arguments.length === 1) { return curOption[key] === undefined ? null : curOption[key]; } curOption[key] = value; } else { if (arguments.length === 1) { return this.options[key] === undefined ? null : this.options[key]; } options[key] = value; } } this._setOptions(options); return this; }, _setOptions: function (options) { var key; for (key in options) { this._setOption(key, options[key]); } return this; }, _setOption: function (key, value) { if (key === "classes") { this._setOptionClasses(value); } this.options[key] = value; if (key === "disabled") { this._setOptionDisabled(value); } return this; }, _setOptionClasses: function (value) { var classKey, elements, currentElements; for (classKey in value) { currentElements = this.classesElementLookup[classKey]; if (value[classKey] === this.options.classes[classKey] || !currentElements || !currentElements.length) { continue; } elements = $(currentElements.get()); this._removeClass(currentElements, classKey); elements.addClass(this._classes({ element: elements, keys: classKey, classes: value, add: true })); } }, _setOptionDisabled: function (value) { this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!value); if (value) { this._removeClass(this.hoverable, null, "ui-state-hover"); this._removeClass(this.focusable, null, "ui-state-focus"); } }, enable: function () { return this._setOptions({ disabled: false }); }, disable: function () { return this._setOptions({ disabled: true }); }, _classes: function (options) { var full = []; var that = this; options = $.extend({ element: this.element, classes: this.options.classes || {} }, options); function processClassString(classes, checkOption) { var current, i; for (i = 0; i < classes.length; i++) { current = that.classesElementLookup[classes[i]] || $(); if (options.add) { current = $($.unique(current.get().concat(options.element.get()))); } else { current = $(current.not(options.element).get()); } that.classesElementLookup[classes[i]] = current; full.push(classes[i]); if (checkOption && options.classes[classes[i]]) { full.push(options.classes[classes[i]]); } } } this._on(options.element, { "remove": "_untrackClassesElement" }); if (options.keys) { processClassString(options.keys.match(/S+/g) || [], true); } if (options.extra) { processClassString(options.extra.match(/S+/g) || []); } return full.join(" "); }, _untrackClassesElement: function (event) { var that = this; $.each(that.classesElementLookup, function (key, value) { if ($.inArray(event.target, value) !== -1) { that.classesElementLookup[key] = $(value.not(event.target).get()); } }); }, _removeClass: function (element, keys, extra) { return this._toggleClass(element, keys, extra, false); }, _addClass: function (element, keys, extra) { return this._toggleClass(element, keys, extra, true); }, _toggleClass: function (element, keys, extra, add) { add = (typeof add === "boolean") ? add : extra; var shift = (typeof element === "string" || element === null), options = { extra: shift ? keys : extra, keys: shift ? element : keys, element: shift ? this.element : element, add: add }; options.element.toggleClass(this._classes(options), add); return this; }, _on: function (suppressDisabledCheck, element, handlers) { var delegateElement; var instance = this; if (typeof suppressDisabledCheck !== "boolean") { handlers = element; element = suppressDisabledCheck; suppressDisabledCheck = false; } if (!handlers) { handlers = element; element = this.element; delegateElement = this.widget(); } else { element = delegateElement = $(element); this.bindings = this.bindings.add(element); } $.each(handlers, function (event, handler) { function handlerProxy() { if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) { return; } return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments); } if (typeof handler !== "string") { handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++; } var match = event.match(/^([w:-]*)s*(.*)$/); var eventName = match[1] + instance.eventNamespace; var selector = match[2]; if (selector) { delegateElement.on(eventName, selector, handlerProxy); } else { element.on(eventName, handlerProxy); } }); }, _off: function (element, eventName) { eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace; element.off(eventName).off(eventName); this.bindings = $(this.bindings.not(element).get()); this.focusable = $(this.focusable.not(element).get()); this.hoverable = $(this.hoverable.not(element).get()); }, _delay: function (handler, delay) { function handlerProxy() { return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments); } var instance = this; return setTimeout(handlerProxy, delay || 0); }, _hoverable: function (element) { this.hoverable = this.hoverable.add(element); this._on(element, { mouseenter: function (event) { this._addClass($(event.currentTarget), null, "ui-state-hover"); }, mouseleave: function (event) { this._removeClass($(event.currentTarget), null, "ui-state-hover"); } }); }, _focusable: function (element) { this.focusable = this.focusable.add(element); this._on(element, { focusin: function (event) { this._addClass($(event.currentTarget), null, "ui-state-focus"); }, focusout: function (event) { this._removeClass($(event.currentTarget), null, "ui-state-focus"); } }); }, _trigger: function (type, event, data) { var prop, orig; var callback = this.options[type]; data = data || {}; event = $.Event(event); event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(); event.target = this.element[0]; orig = event.originalEvent; if (orig) { for (prop in orig) { if (!(prop in event)) { event[prop] = orig[prop]; } } } this.element.trigger(event, data); return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented()); } }; $.each({ show: "fadeIn", hide: "fadeOut" }, function (method, defaultEffect) { $.Widget.prototype["_" + method] = function (element, options, callback) { if (typeof options === "string") { options = { effect: options }; } var hasOptions; var effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect; options = options || {}; if (typeof options === "number") { options = { duration: options }; } hasOptions = !$.isEmptyObject(options); options.complete = callback; if (options.delay) { element.delay(options.delay); } if (hasOptions && $.effects && $.effects.effect[effectName]) { element[method](options); } else if (effectName !== method && element[effectName]) { element[effectName](options.duration, options.easing, callback); } else { element.queue(function (next) { $(this)[method](); if (callback) { callback.call(element[0]); } next(); }); } }; }); var widget = $.widget; var form = $.fn.form = function () { return typeof this[0].form === "string" ? this.closest("form") : $(this[0].form); }; /*! * jQuery UI Form Reset Mixin 1.12.1 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license */ var formResetMixin = $.ui.formResetMixin = { _formResetHandler: function () { var form = $(this); setTimeout(function () { var instances = form.data("ui-form-reset-instances"); $.each(instances, function () { this.refresh(); }); }); }, _bindFormResetHandler: function () { this.form = this.element.form(); if (!this.form.length) { return; } var instances = this.form.data("ui-form-reset-instances") || []; if (!instances.length) { this.form.on("reset.ui-form-reset", this._formResetHandler); } instances.push(this); this.form.data("ui-form-reset-instances", instances); }, _unbindFormResetHandler: function () { if (!this.form.length) { return; } var instances = this.form.data("ui-form-reset-instances"); instances.splice($.inArray(this, instances), 1); if (instances.length) { this.form.data("ui-form-reset-instances", instances); } else { this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset"); } } }; var escapeSelector = $.ui.escapeSelector = (function () { var selectorEscape = /([!"#$%&'()*+,./:;<=>?@[]^`{|}~])/g; return function (selector) { return selector.replace(selectorEscape, "\$1"); }; })(); /*! * jQuery UI Labels 1.12.1 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license */ var labels = $.fn.labels = function () { var ancestor, selector, id, labels, ancestors; if (this[0].labels && this[0].labels.length) { return this.pushStack(this[0].labels); } labels = this.eq(0).parents("label"); id = this.attr("id"); if (id) { ancestor = this.eq(0).parents().last(); ancestors = ancestor.add(ancestor.length ? ancestor.siblings() : this.siblings()); selector = "label[for='" + $.ui.escapeSelector(id) + "']"; labels = labels.add(ancestors.find(selector).addBack(selector)); } return this.pushStack(labels); }; /*! * jQuery UI Checkboxradio 1.12.1 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license */ $.widget("ui.checkboxradio", [$.ui.formResetMixin, { version: "1.12.1", options: { disabled: null, label: null, icon: true, classes: { "ui-checkboxradio-label": "ui-corner-all", "ui-checkboxradio-icon": "ui-corner-all" } }, _getCreateOptions: function () { var disabled, labels; var that = this; var options = this._super() || {}; this._readType(); labels = this.element.labels(); this.label = $(labels[labels.length - 1]); if (!this.label.length) { $.error("No label found for checkboxradio widget"); } this.originalLabel = ""; this.label.contents().not(this.element[0]).each(function () { that.originalLabel += this.nodeType === 3 ? $(this).text() : this.outerHTML; }); if (this.originalLabel) { options.label = this.originalLabel; } disabled = this.element[0].disabled; if (disabled != null) { options.disabled = disabled; } return options; }, _create: function () { var checked = this.element[0].checked; this._bindFormResetHandler(); if (this.options.disabled == null) { this.options.disabled = this.element[0].disabled; } this._setOption("disabled", this.options.disabled); this._addClass("ui-checkboxradio", "ui-helper-hidden-accessible"); this._addClass(this.label, "ui-checkboxradio-label", "ui-button ui-widget"); if (this.type === "radio") { this._addClass(this.label, "ui-checkboxradio-radio-label"); } if (this.options.label && this.options.label !== this.originalLabel) { this._updateLabel(); } else if (this.originalLabel) { this.options.label = this.originalLabel; } this._enhance(); if (checked) { this._addClass(this.label, "ui-checkboxradio-checked", "ui-state-active"); if (this.icon) { this._addClass(this.icon, null, "ui-state-hover"); } } this._on({ change: "_toggleClasses", focus: function () { this._addClass(this.label, null, "ui-state-focus ui-visual-focus"); }, blur: function () { this._removeClass(this.label, null, "ui-state-focus ui-visual-focus"); } }); }, _readType: function () { var nodeName = this.element[0].nodeName.toLowerCase(); this.type = this.element[0].type; if (nodeName !== "input" || !/radio|checkbox/.test(this.type)) { $.error("Can't create checkboxradio on element.nodeName=" + nodeName + " and element.type=" + this.type); } }, _enhance: function () { this._updateIcon(this.element[0].checked); }, widget: function () { return this.label; }, _getRadioGroup: function () { var group; var name = this.element[0].name; var nameSelector = "input[name='" + $.ui.escapeSelector(name) + "']"; if (!name) { return $([]); } if (this.form.length) { group = $(this.form[0].elements).filter(nameSelector); } else { group = $(nameSelector).filter(function () { return $(this).form().length === 0; }); } return group.not(this.element); }, _toggleClasses: function () { var checked = this.element[0].checked; this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", checked); if (this.options.icon && this.type === "checkbox") { this._toggleClass(this.icon, null, "ui-icon-check ui-state-checked", checked)._toggleClass(this.icon, null, "ui-icon-blank", !checked); } if (this.type === "radio") { this._getRadioGroup().each(function () { var instance = $(this).checkboxradio("instance"); if (instance) { instance._removeClass(instance.label, "ui-checkboxradio-checked", "ui-state-active"); } }); } }, _destroy: function () { this._unbindFormResetHandler(); if (this.icon) { this.icon.remove(); this.iconSpace.remove(); } }, _setOption: function (key, value) { if (key === "label" && !value) { return; } this._super(key, value); if (key === "disabled") { this._toggleClass(this.label, null, "ui-state-disabled", value); this.element[0].disabled = value; return; } this.refresh(); }, _updateIcon: function (checked) { var toAdd = "ui-icon ui-icon-background "; if (this.options.icon) { if (!this.icon) { this.icon = $("<span>"); this.iconSpace = $("<span> </span>"); this._addClass(this.iconSpace, "ui-checkboxradio-icon-space"); } if (this.type === "checkbox") { toAdd += checked ? "ui-icon-check ui-state-checked" : "ui-icon-blank"; this._removeClass(this.icon, null, checked ? "ui-icon-blank" : "ui-icon-check"); } else { toAdd += "ui-icon-blank"; } this._addClass(this.icon, "ui-checkboxradio-icon", toAdd); if (!checked) { this._removeClass(this.icon, null, "ui-icon-check ui-state-checked"); } this.icon.prependTo(this.label).after(this.iconSpace); } else if (this.icon !== undefined) { this.icon.remove(); this.iconSpace.remove(); delete this.icon; } }, _updateLabel: function () { var contents = this.label.contents().not(this.element[0]); if (this.icon) { contents = contents.not(this.icon[0]); } if (this.iconSpace) { contents = contents.not(this.iconSpace[0]); } contents.remove(); this.label.append(this.options.label); }, refresh: function () { var checked = this.element[0].checked, isDisabled = this.element[0].disabled; this._updateIcon(checked); this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", checked); if (this.options.label !== null) { this._updateLabel(); } if (isDisabled !== this.options.disabled) { this._setOptions({ "disabled": isDisabled }); } } }]); var widgetsCheckboxradio = $.ui.checkboxradio; }));